{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Next-generation developer-first NoSQL database.</p> <p>AnnaDB is an in-memory data store with disk persistence. It can work as the main data storage and the cache layer as well. Rust lang under the hood makes it memory-safe and fast.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flexible object structure - simple primitives and complicated nested containers could be stored in AnnaDB</li> <li>Relations - you can link any object to another, and AnnaDB will resolve this relation on finds, updates, and other operations.</li> <li>Transactions - out of the box</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation</li> <li>GitHub Repo</li> <li>Docker Hub</li> <li>Discord Server</li> </ul>"},{"location":"install/","title":"Install","text":""},{"location":"install/#server","title":"Server","text":"<pre><code>docker run --init -p 10001:10001 -t romanright/annadb:0.2.0\n</code></pre> <p>Alternatively, you can persist your data:</p> <pre><code>docker run --init -p 10001:10001 -t -v \"$(pwd)/data:/app/warehouse\" romanright/annadb:0.2.0\n</code></pre>"},{"location":"install/#client-shell","title":"Client shell","text":"<p>Install</p> <pre><code>pip install annadb\n</code></pre> <p>Run</p> <pre><code>annadb --uri annadb://localhost:10001\n</code></pre>"},{"location":"install/#playground","title":"Playground","text":"<p>Alternatively, you can try AnnaDB using the public playground connection string:</p> <pre><code>annadb --uri annadb://playground.annadb.dev:10001\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<p>the dates could be changed during the development</p>"},{"location":"roadmap/#data-structures","title":"Data Structures","text":"<p>I plan to add more container data types to make working with different data fields more comfortable.</p>"},{"location":"roadmap/#geo-points","title":"Geo Points","text":"<p>Geo Points are points with coordinates to represent geographical data.</p>"},{"location":"roadmap/#graph-vertices","title":"Graph Vertices","text":"<p>To represent complex graph schemas graph vertices data structure will be added.</p>"},{"location":"roadmap/#indices","title":"Indices","text":"<p>To search data effectively, some kinds of indexes will be implemented.</p>"},{"location":"roadmap/#b-tree","title":"B-Tree","text":"<p>B-Tree is a classic index that helps compare, search and sort many data types effectively.</p>"},{"location":"roadmap/#text","title":"Text","text":"<p>The text index is needed to support full-text search over one or more text fields.</p>"},{"location":"roadmap/#geo","title":"Geo","text":"<p>Geo index helps to use geo operations like search in the area or search the nearest point effectively.</p>"},{"location":"roadmap/#query","title":"Query","text":"<p>Some new query types and operators will be implemented to support more use cases.</p>"},{"location":"roadmap/#projections","title":"Projections","text":"<p>Using projections, you will be allowed to set the output data format.</p>"},{"location":"roadmap/#text-search","title":"Text search","text":"<p>Text search queries are used to search large amounts of text.</p>"},{"location":"roadmap/#geo-operations","title":"Geo operations","text":"<p>To work with geo data, some geo operations will be implemented.</p>"},{"location":"roadmap/#graph-operations","title":"Graph operations","text":"<p>Graph operations help to work with graph structures.</p>"},{"location":"roadmap/#user-management","title":"User Management","text":"<p>User management is an essential part of the database. It will be implemented by version 1.0 too.</p>"},{"location":"roadmap/#authentification","title":"Authentification","text":"<p>The authentification manager checks the user credentials before giving the data access.</p>"},{"location":"roadmap/#roles","title":"Roles","text":"<p>Different user roles will be supported: admin, writer, and reader.</p>"},{"location":"roadmap/#rights","title":"Rights","text":"<p>Per-collection access rights could be customized for each user</p>"},{"location":"articles/first/","title":"First","text":"<p>I'm excited to introduce AnnaDB - the next-generation developer-first NoSQL data store.</p> <p>I work with many small projects daily - proofs of concepts and experiments with new frameworks or patterns. For these purposes, I needed a database that works with flexible data structures, as I change it frequently during my experiments. And it must support relations out of the box, as this is a natural part of the structures' design - links to other objects. I tried a lot (if not all) databases, but nothing fit my requirements well. So, I decided to make my own then. This is how AnnaDB was born.</p> <p>AnnaDB is an in-memory data store with disk persistence. It is written with Rust, a memory-safe compilable language. AnnaDB is fast and safe enough to be and the main data storage, and the cache layer.</p> <p>Features</p> <ul> <li>Flexible object structure - simple primitives and complicated nested containers could be stored in AnnaDB</li> <li>Relations - you can link any object to another, and AnnaDB will resolve this relation on finds, updates, and other operations.</li> <li>Transactions - out of the box</li> </ul>"},{"location":"articles/first/#basics","title":"Basics","text":"<p>I want to start with the basic concepts and examples of the syntax here and continue with the usage example.</p>"},{"location":"articles/first/#collections","title":"Collections","text":"<p>AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. </p> <p>Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link (id). This link consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups)</p>"},{"location":"articles/first/#tyson","title":"TySON","text":"<p>The AnnaDB query language uses the <code>TySON</code> format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data or query type (as it is used in AnnaDB) or any other useful for the parser information. This adds more flexibility to the data structure design - it is allowed to use as many custom data types as the developer needs.</p> <p>You can read more about the <code>TySON</code> format here</p>"},{"location":"articles/first/#data-types","title":"Data Types","text":"<p>There are primitive and container data types in AnnaDB.</p> <p>Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as <code>prefix|value|</code> or <code>prefix</code> only. Prefix in AnnaDB shows the data type. For example, the string <code>test</code> will be represented as <code>s|test|</code>, where <code>s</code> - is a prefix that marks data as a string, and <code>test</code> is the actual value.</p> <p>Container data types keep primitive and container objects using specific rules. There are only two container types in AnnaDB for now. Maps and vectors.</p> <ul> <li>Vectors are ordered sets of elements of any type. Example: <code>v[n|1|,n|2|,n|3|,]</code></li> <li>Maps are associative arrays. Example: <code>m{ s|bar|: s|baz|,}</code></li> </ul> <p>More information about AnnaDB data types can be found in the documentation</p>"},{"location":"articles/first/#query","title":"Query","text":"<p>Query in AnnaDB is a pipeline of steps that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix <code>q</code> - query.</p> <pre><code>collection|test|:q[\n   find[\n   ],\n   sort[\n      asc(value|num|),\n   ],\n   limit(n|5|),\n];\n</code></pre> <p>If the pipeline has only one step, the <code>q</code> vector is not needed.</p> <pre><code>collection|test|:find[\n   gt{\n      value|num|:n|4|,\n   },\n];\n</code></pre>"},{"location":"articles/first/#server","title":"Server","text":"<p>To run AnnaDB locally please type the next command in the terminal:</p> <pre><code>docker run --init -p 10001:10001 -t romanright/annadb:0.1.0\n</code></pre>"},{"location":"articles/first/#client","title":"Client","text":"<p>AnnaDB shell client is an interactive terminal application that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually.</p> <p></p> <p>It can be installed via <code>pip</code></p> <pre><code>pip install annadb\n</code></pre> <p>Run</p> <pre><code>annadb --uri annadb://localhost:10001\n</code></pre>"},{"location":"articles/first/#usage-example","title":"Usage example","text":"<p>You are prepared for the fun part of the article now. Let's play with AnnaDB!</p> <p>I'll create a database for the candy store to show the features.</p>"},{"location":"articles/first/#insert-primitive","title":"Insert primitive","text":"<p>Let's start with categories. I'll represent categories as simple string objects. Let's insert the first one into the <code>categories</code> collection.</p> <p>Request:</p> <pre><code>collection|categories|:insert[\n    s|sweets|,\n];\n</code></pre> <p><code>collection|categories|</code> shows on which collection the query will be applied. In our case - <code>categories</code>.</p> <p><code>insert[...]</code> - is a query step. You can insert one or many objects using the <code>insert</code> operation.</p> <p><code>s|sweets|</code> - is the object to insert. In this case, it is a string primitive. Prefix <code>s</code> means that it is a string, <code>|</code> wrap the value of the primitive. Other primitive types could be found in the Data Types section.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            categories|88690111-62ad-4631-b12b-2a4fe7caa1cf|,\n        ],\n        s|meta|:insert_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>If everything is ok, the result will have an <code>ok[...]</code> vector with responses for all the transaction pipelines. Each response contains <code>data</code> and <code>meta</code> information. In our case, there is only one response with a vector of <code>ids</code> in <code>data</code> and a number of inserted objects in <code>meta</code>.</p>"},{"location":"articles/first/#insert-container","title":"Insert container","text":"<p>Let's insert a more complicated object now - a chocolate bar. It will have fields:</p> <ul> <li>name</li> <li>price</li> <li>category</li> </ul> <p>For the category, I'll use the already created one.</p> <p>Request:</p> <pre><code>collection|products|:insert[\n    m{\n        s|name|:s|Tony's|,\n        s|price|:n|5.95|,\n        s|category|:categories|88690111-62ad-4631-b12b-2a4fe7caa1cf|,\n    },\n];\n</code></pre> <p>The query is similar to the previous one, but the object is not a primitive but a map. The value of the <code>category</code> field is a link that was received after the previous insert.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|,\n        ],\n        s|meta|:insert_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response is nearly the same as before - link in data and number of inserted objects in meta.</p>"},{"location":"articles/first/#get-object","title":"Get object","text":"<p>Let's retrieve the information about this chocolate bar now. I'll use the <code>get</code> operation for this, to the object by id</p> <p>Request:</p> <pre><code>collection|products|:get[\n    products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|,\n];\n</code></pre> <p>This time I use the <code>get[...]</code> query step. Using this step you can retrieve one or many objects using object links.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|:m{\n                s|name|:s|Tony's|,\n                s|category|:s|sweets|,\n                s|price|:n|5.95|,\n            },\n        },\n        s|meta|:get_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>In the response here you can see the <code>objects{...}</code> map, where keys are links to objects and values are objects. <code>objects{}</code> map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step.</p> <p>The category was fetched automatically and the value was returned.</p> <p>Let's insert another chocolate bar there to have more objects in the collection:</p> <pre><code>collection|products|:insert[\n    m{\n        s|name|:s|Mars|,\n        s|price|:n|2|,\n        s|category|:categories|88690111-62ad-4631-b12b-2a4fe7caa1cf|,\n    },\n];\n</code></pre> <p>I use the same category id for this bar.</p>"},{"location":"articles/first/#modify-primitive","title":"Modify primitive","text":"<p>Let's modify the category to make it more accurate.</p> <p>Request:</p> <pre><code>collection|categories|:q[\n    get[\n        categories|88690111-62ad-4631-b12b-2a4fe7caa1cf|,\n    ],\n    update[\n        set{\n            root:s|chocolate|,\n        },\n    ],\n];\n</code></pre> <p>The query here consists of 2 steps. <code>Get the object by link</code> step and <code>modify this object</code> step. The <code>update[...]</code> operation is a vector of update operators. Read more about the update.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            categories|88690111-62ad-4631-b12b-2a4fe7caa1cf|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta.</p> <p>Let's take a look at how this affected the chocolate objects.</p> <p>Request:</p> <pre><code>collection|products|:find[\n];\n</code></pre> <p>To find objects, I use the <code>find[...]</code> operation. It is a vector of find operators. If it is empty, all the collection objects will be returned.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|02a2a5cd-0c56-45f7-8cad-7838446cfc49|:m{\n                s|name|:s|Mars|,\n                s|category|:s|chocolate|,\n                s|price|:n|2|,\n            },\n            products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|:m{\n                s|price|:n|5.95|,\n                s|name|:s|Tony's|,\n                s|category|:s|chocolate|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre> <p>The category was changed for both products, as the category object was linked with these objects.</p>"},{"location":"articles/first/#modify-container","title":"Modify container","text":"<p>Now I'll increase the price of the bars, where it is less than 2</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n        lt{\n            value|price|:n|3|,\n        },\n    ],\n    update[\n        inc{\n            value|price|:n|2|,\n        },\n    ],\n];\n</code></pre> <p>The <code>find</code> step can stay before the <code>update</code> step as well. All the found objects will be updated. Read more about <code>find</code> operation and operators here.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            products|02a2a5cd-0c56-45f7-8cad-7838446cfc49|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response is similar to the previous one.</p> <p>Here is how all the products look like after the update:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|02a2a5cd-0c56-45f7-8cad-7838446cfc49|:m{\n                s|name|:s|Mars|,\n                s|price|:n|4|,\n                s|category|:s|chocolate|,\n            },\n            products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|:m{\n                s|category|:s|chocolate|,\n                s|price|:n|5.95|,\n                s|name|:s|Tony's|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre>"},{"location":"articles/first/#sort-objects","title":"Sort objects","text":"<p>To sort objects, I'll use the <code>sort</code> operation against the price field.</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n    ],\n    sort[\n        asc(value|price|),\n    ],\n];\n</code></pre> <p>The <code>sort[...]</code> operation is a vector of sort operators - <code>asc</code> and <code>desc</code>. Sort operators are modifiers that contain paths to the sorting value. The <code>sort</code> operation is not an independent step, it can stay only after find-like operations that return objects. You can read more about sort here</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|02a2a5cd-0c56-45f7-8cad-7838446cfc49|:m{\n                s|name|:s|Mars|,\n                s|price|:n|4|,\n                s|category|:s|chocolate|,\n            },\n            products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|:m{\n                s|category|:s|chocolate|,\n                s|name|:s|Tony's|,\n                s|price|:n|5.95|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre> <p>Objects in the response are sorted by price now.</p> <p>It is useful to use <code>limit</code> and <code>offset</code> operations together with sort. You can read about them in the documentation</p>"},{"location":"articles/first/#delete-objects","title":"Delete objects","text":"<p>After any find-like step, you can use the <code>delete</code> operation to delete all the found objects. Or it can be used independently to delete the whole collection.</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n        gt{\n            value|price|:n|5|,\n        },\n    ],\n    delete,\n];\n</code></pre> <p>The <code>delete</code> operation is a primitive without value.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            products|91f5236c-e4cd-43c7-af5b-7534e5ba2c32|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response contains affected ids in <code>data</code> and the number of deleted objects in <code>meta</code>.</p>"},{"location":"articles/first/#using-from-your-app","title":"Using from your app","text":"<p>AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too.</p> <ul> <li>Link to the PyPI repo</li> <li>Python tutorial</li> </ul> <p>I'll add drivers for other languages soon. If you can help me with it, I'll be more than happy :)</p>"},{"location":"articles/first/#plans","title":"Plans","text":"<p>This is the very early version of the database. It can already do things, and I use it in a few of my projects. But there are many features to work on yet.</p>"},{"location":"articles/first/#drivers","title":"Drivers","text":"<p>I plan to add drivers to support the most popular languages, like <code>JS</code>, <code>Rust</code>, <code>Go</code>, and others. If you can help with this - please get in touch with me.</p>"},{"location":"articles/first/#rights-management","title":"Rights management","text":"<p>This is probably the most important feature to implement. Authentication, authorizations, roles, etc.</p>"},{"location":"articles/first/#performance-increase","title":"Performance increase","text":"<p>There are many performance-related things to improve now. </p>"},{"location":"articles/first/#query-features","title":"Query features","text":"<ul> <li>Projections</li> <li>More find and update operators</li> <li>Developer experience improves</li> </ul>"},{"location":"articles/first/#data-types_1","title":"Data Types","text":"<p>I plan to add more data types like geo points and graph vertices to make AnnaDB more comfortable working with different data fields.</p>"},{"location":"articles/first/#managed-service","title":"Managed service","text":"<p>My big goal is to make a managed data store service. Hey, AWS, Google Cloud, MS Azure, I'm ready for collaborations! ;)</p>"},{"location":"articles/first/#links","title":"Links","text":"<ul> <li>Documentation - https://annadb.dev</li> <li>GitHub Repo - https://github.com/roman-right/AnnaDB</li> <li>Python Driver - https://pypi.org/project/annadb/</li> <li>My Twitter - https://twitter.com/roman_the_right</li> </ul> <p>If you face any bug or weird behavior, please, let me know.</p>"},{"location":"documentation/data_types/","title":"Data Types","text":"<p>There are primitive and container data types in AnnaDB.</p>"},{"location":"documentation/data_types/#primitives","title":"Primitives","text":"<p>Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as <code>prefix|value|</code> or <code>prefix</code> only. Prefix in AnnaDB shows the data type.</p> Type Description Prefix Example Number Integer or float point number n <code>n|101|</code> String Any string. `|` symbols must be escaped with `\\` s <code>s|Lorem ipsum|</code> Bool A boolean value b <code>b|true|</code> Null A marker that indicating that something has no value null <code>null</code> Unix Timestamp  The number of seconds that have elapsed since the Unix epoch uts <code>uts|123456789|</code> Link  Id of an object. The collection name is used for the prefix Collection name  <code>users|e0bbcda2-0911-495e-9f0f-ce00db489f10|</code>"},{"location":"documentation/data_types/#containers","title":"Containers","text":"<p>Container data types keep primitive and container objects using specific rules.</p> Type Description Prefix Example Vector An ordered set of elements of any type v <code>v[n|1|,n|2|,n|3|,]</code> Map An associative array m <code>m{   s|bar|:   s|baz|,}</code>"},{"location":"documentation/delete/","title":"Delete","text":"<p>Remove found objects or the whole collection.</p> <p>Prefix: <code>delete</code></p> <p>Value: no value. Prefix-only primitive</p> <p>Can start the pipeline: No</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: -</p>"},{"location":"documentation/delete/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:q[\n    find[\n        gt{\n            value|num|:n|5|,\n        },\n    ],\n    delete,\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            test|edade018-1f2c-48ec-8d69-e6353fe73154|,\n            test|900eab76-59cd-49c8-af3f-e5125294dd04|,\n            test|5113ba7d-88cc-47f4-b3cf-c0ef89257179|,\n            test|d2210a19-968a-46f3-8e5d-09bd754fa229|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|4|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/find/","title":"Find","text":"<p>Find objects using comparison and logical operators</p> <p>Prefix: <code>find</code></p> <p>Value: Vector of operators</p> <p>Can start the pipeline: Yes</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: find, get, sort, limit, offset, update, delete</p>"},{"location":"documentation/find/#comparison-operators","title":"Comparison operators","text":"<ul> <li>Equal - <code>eq{...}</code></li> <li>Not equal - <code>neq{...}</code></li> <li>Greater than - <code>gt{...}</code></li> <li>Greater than or equeal - <code>gte{...}</code></li> <li>Less than - <code>lt{...}</code></li> <li>Less than or equal - <code>lte{...}</code></li> <li>Less than or equal - <code>lte{...}</code></li> </ul>"},{"location":"documentation/find/#logical-operators","title":"Logical operators","text":"<ul> <li>And - <code>and[...]</code></li> <li>Or - <code>or[...]</code></li> <li>Not - <code>not(...)</code></li> </ul> <p>In order to compare the value of the object <code>root path</code> notation could be used:</p> <pre><code>eq{root: s|bar|}\n</code></pre> <p>In order to compare a field of the object <code>path to value</code> notation could be used:</p> <pre><code>eq{value|path.to.field|: s|bar|}\n</code></pre>"},{"location":"documentation/find/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:find[\n    gt{\n        value|num|:n|4|,\n    },\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            test|ed75e748-c173-4d56-8376-b780c4364b40|:m{\n                s|num|:n|5|,\n                s|name|:s|test_5|,\n            },\n            test|b89c8f7f-858e-487c-b134-ef1b7a1060dc|:m{\n                s|name|:s|test_9|,\n                s|num|:n|9|,\n            },\n            test|dfc92830-68e0-4d78-b4c1-f821f570eb9a|:m{\n                s|name|:s|test_6|,\n                s|num|:n|6|,\n            },\n            test|31364c30-110d-47f5-9ad7-1e378b05b63b|:m{\n                s|num|:n|7|,\n                s|name|:s|test_7|,\n            },\n            test|74b7fbcc-e681-45f7-a1e2-76b6b8c379f7|:m{\n                s|name|:s|test_8|,\n                s|num|:n|8|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|5|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/get/","title":"Get","text":"<p>Get one or many objects by id (link)</p> <p>Prefix: <code>get</code></p> <p>Value: Vector of links</p> <p>Can start the pipeline: Yes</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: find, get, sort, limit, offset, update, delete</p>"},{"location":"documentation/get/#examples","title":"Examples","text":"<pre><code>collection|test|:get[\n    test|7458a618-d907-4855-9f78-56b8a7343634|,\n    test|cee4c1a0-c7ed-4856-b766-d0ec78cbc432|,\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            test|7458a618-d907-4855-9f78-56b8a7343634|:s|foo|,\n            test|cee4c1a0-c7ed-4856-b766-d0ec78cbc432|:s|bar|,\n        },\n        s|meta|:get_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/insert/","title":"Insert","text":"<p>Insert one or many primitive or container objects</p> <p>Prefix: <code>insert</code></p> <p>Value: Vector of object</p> <p>Can start the pipeline: Yes</p> <p>Steps before: -</p> <p>Steps after: -</p>"},{"location":"documentation/insert/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:insert[\n    s|foo|,\n    n|100|,\n    b|true|,\n    v[\n        n|1|,\n        n|2|,\n        n|3|,\n    ],\n    m{\n        s|bar|:s|baz|,\n    },\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            test|fdb48035-d16d-4616-8ee2-aad704e94740|,\n            test|30e74bba-d6ca-4a49-a06c-55755cba54ee|,\n            test|fd00b0a5-3d77-46b7-adeb-f7d6ee510863|,\n            test|da616bf9-edd2-45aa-91fb-46cf39bb28c2|,\n            test|854b8d89-ca2a-4adf-9125-f761f638fcd7|,\n        ],\n        s|meta|:insert_meta{\n            s|count|:n|5|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/introduction/","title":"Introduction","text":""},{"location":"documentation/introduction/#collections","title":"Collections","text":"<p>AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. </p> <p>Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link id. This id consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups)</p>"},{"location":"documentation/introduction/#tyson","title":"TySON","text":"<p>AnnaDB query language uses the <code>TySON</code> format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data type or query type (as it is used in AnnaDB) or any other information, useful for the parser. This adds more flexibility to the data structure design - it is allowed to use as many custom data types, as the developer needs.</p> <p>You can read more about the <code>TySON</code> format here</p>"},{"location":"documentation/introduction/#query","title":"Query","text":"<p>Query in AnnaDB is a pipeline of steps, that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix <code>q</code> - query.</p> <pre><code>collection|test|:q[\n    find[\n    ],\n    sort[\n        asc(value|num|),\n    ],\n    limit(n|5|),\n];\n</code></pre> <p>If the pipeline has only one step, the <code>q</code> vector is not needed.</p> <pre><code>collection|test|:find[\n    gt{\n        value|num|:n|4|,\n    },\n];\n</code></pre>"},{"location":"documentation/introduction/#transaction","title":"Transaction","text":"<p>Every database call is a transaction with AnnaDB. You can send as many queries as you want together in a single call. If something will go wrong in the middle, all the queries in this transaction will be rolled back. Results of all the queries will be returned together in a vector in the respective order.</p> <pre><code>collection|test|:q[\n    find[\n        gt{\n            value|num|:n|4|,\n        },\n    ],\n    update[\n        set{\n            value|blink2.a|:n|100|,\n        },\n    ],\n];\ncollection|test|:q[\n    find[\n    ],\n    update[\n        set{\n            value|blink2.e|:n|1000|,\n        },\n    ],\n];\n</code></pre>"},{"location":"documentation/introduction/#client","title":"Client","text":"<p>AnnaDB shell client is an interactive terminal application, that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually.</p> <p></p>"},{"location":"documentation/introduction/#using-from-your-app","title":"Using from your app","text":"<p>AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too.</p> <p>LINK</p> <p>Other languages will be supported soon too. If you want to help me with this, please text me - I'll provide all the information and tools.</p>"},{"location":"documentation/limit/","title":"Limit","text":"<p>Limit number of found objects</p> <p>Prefix: <code>limit</code></p> <p>Value: Modifier with a number</p> <p>Can start the pipeline: No</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: find, get, sort, limit, offset, update, delete</p>"},{"location":"documentation/limit/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:q[\n    find[\n    ],\n    sort[\n        asc(value|num|),\n    ],\n    limit(n|5|),\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            test|0d28f996-c6cb-4c75-a1c7-3c2a844a316b|:m{\n                s|name|:s|test_0|,\n                s|num|:n|0|,\n            },\n            test|7ba4f95d-44f2-4f83-8fc4-d825af767d7b|:m{\n                s|name|:s|test_1|,\n                s|num|:n|1|,\n            },\n            test|b6afa3fc-6829-4c94-9105-979dce2324bd|:m{\n                s|name|:s|test_2|,\n                s|num|:n|2|,\n            },\n            test|79ea1b39-8e90-45c3-8b45-b122c25a9d53|:m{\n                s|num|:n|3|,\n                s|name|:s|test_3|,\n            },\n            test|7aafba5b-17b7-478e-b9b4-79b78f549728|:m{\n                s|num|:n|4|,\n                s|name|:s|test_4|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|5|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/offset/","title":"Offset","text":"<p>Skip number of found objects</p> <p>Prefix: <code>offset</code></p> <p>Value: Modifier with a number</p> <p>Can start the pipeline: No</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: find, get, sort, limit, offset, update, delete</p>"},{"location":"documentation/offset/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:q[\n    find[\n    ],\n    sort[\n        asc(value|num|),\n    ],\n    offset(n|5|),\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            test|701f0bf2-e17f-4823-b410-83a418e035ca|:m{\n                s|num|:n|5|,\n                s|name|:s|test_5|,\n            },\n            test|9b14220b-209d-4b19-860d-cba7d99ec0b2|:m{\n                s|num|:n|6|,\n                s|name|:s|test_6|,\n            },\n            test|19d9133d-5291-40b2-8a92-d6892e693d12|:m{\n                s|num|:n|7|,\n                s|name|:s|test_7|,\n            },\n            test|8d6a06fb-670a-4f39-aa9e-3f613ed3c8a3|:m{\n                s|name|:s|test_8|,\n                s|num|:n|8|,\n            },\n            test|2fb8117b-e131-42af-b4a2-a4e525918b16|:m{\n                s|name|:s|test_9|,\n                s|num|:n|9|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|5|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/pipelines/","title":"Pipelines","text":""},{"location":"documentation/pipelines/#query-set","title":"Query Set","text":"<p>Query in the AnnaDB is a pipeline of steps, that should be applied for a collection.</p>"},{"location":"documentation/pipelines/#transaction","title":"Transaction","text":""},{"location":"documentation/project/","title":"Project","text":"<p>Modify the output data using projection template</p> <p>Prefix: <code>project</code></p> <p>Value: Map of fields</p> <p>Can start the pipeline: No</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: -</p>"},{"location":"documentation/project/#operators","title":"Operators","text":"<ul> <li>Keep - <code>keep</code> - keep the respective value</li> </ul>"},{"location":"documentation/project/#usage","title":"Usage","text":"<p>In order to keep a field or subfield of the object <code>keep</code> operator could be used:</p> <pre><code>s|field|:keep,\ns|map|:m{\ns|field_2|:keep,\n},\n</code></pre> <p>To set an existing value to a new field <code>value</code> notation could be used:</p> <pre><code>s|new_field|:value|field|,\n</code></pre> <p>To set a new value to a field primitives, maps or vectors could be used:</p> <pre><code>s|field_1|:s|new value|,\n\ns|field_2|:m{\ns|field|:s|new value|,\n},\n\ns|field_3|:v[\ns|new value|,\n],\n</code></pre>"},{"location":"documentation/project/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:q[\n    find[\n    ],\n    project{\n        s|name|:s|foo|,\n        s|num|:keep,\n        s|vec|:v[\n            keep,\n            n|1|,\n        ],\n        s|map|:m{\n            s|bar|:keep,\n            s|test|:s|test|,\n        },\n        s|new_field|:s|new_value|,\n    },\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            test|21a48bd5-9619-4a3f-9d45-353e3394288b|:m{\n                s|map|:m{\n                    s|test|:s|test|,\n                    s|bar|:s|baz|,\n                },\n                s|vec|:v[\n                    n|1|,\n                    n|1|,\n                ],\n                s|name|:s|foo|,\n                s|num|:n|1|,\n                s|new_field|:s|new_value|,\n            },\n            test|b1bbfe13-7da7-4407-928e-bd380fb9bde9|:m{\n                s|map|:m{\n                    s|bar|:s|baz|,\n                    s|test|:s|test|,\n                },\n                s|num|:n|2|,\n                s|new_field|:s|new_value|,\n                s|vec|:v[\n                    n|1|,\n                    n|1|,\n                ],\n                s|name|:s|foo|,\n            },\n            test|b47f6214-d49c-459f-bfff-e6450ad418ae|:m{\n                s|num|:n|0|,\n                s|name|:s|foo|,\n                s|vec|:v[\n                    n|1|,\n                    n|1|,\n                ],\n                s|new_field|:s|new_value|,\n                s|map|:m{\n                    s|bar|:s|baz|,\n                    s|test|:s|test|,\n                },\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|3|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/sort/","title":"Sort","text":"<p>Sort found objects</p> <p>Prefix: <code>sort</code></p> <p>Value: Vector of sort operators</p> <p>Can start the pipeline: No</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: find, get, sort, limit, offset, update, delete</p> <p>Sort operators:</p> <ul> <li>Asc - <code>asc(...)</code></li> <li>Desc - <code>desc(...)</code></li> </ul>"},{"location":"documentation/sort/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:q[\n    find[\n    ],\n    sort[\n        asc(value|num|),\n    ],\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            test|ab8b1e57-f34b-48f5-a921-d9b8895e420b|:m{\n                s|name|:s|test_0|,\n                s|num|:n|0|,\n            },\n            test|bea8bd4f-66e6-4ff2-8e13-d4cf47ff9597|:m{\n                s|name|:s|test_1|,\n                s|num|:n|1|,\n            },\n            test|fc8516b2-a9bb-47e9-a50d-c69062a9400f|:m{\n                s|num|:n|2|,\n                s|name|:s|test_2|,\n            },\n            test|7db1109e-4db1-4bef-8b1f-ab806abb308e|:m{\n                s|num|:n|3|,\n                s|name|:s|test_3|,\n            },\n            test|db9d1e00-b418-40ba-b570-af6236fb8821|:m{\n                s|name|:s|test_4|,\n                s|num|:n|4|,\n            },\n            test|fc2b9769-ef88-40b7-93cf-966d736af951|:m{\n                s|num|:n|5|,\n                s|name|:s|test_5|,\n            },\n            test|afdc54f9-4d38-40bf-a99d-4c339d8ba217|:m{\n                s|num|:n|6|,\n                s|name|:s|test_6|,\n            },\n            test|04432679-9f31-4197-ae04-abdaf0d852b5|:m{\n                s|num|:n|7|,\n                s|name|:s|test_7|,\n            },\n            test|d0dcb28a-2722-491d-8391-e23b227f6ba4|:m{\n                s|name|:s|test_8|,\n                s|num|:n|8|,\n            },\n            test|10ea91c8-ce57-4969-84fb-72d19551a571|:m{\n                s|name|:s|test_9|,\n                s|num|:n|9|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|10|,\n        },\n    },\n];\n</code></pre>"},{"location":"documentation/update/","title":"Update","text":"<p>Update values of found objects</p> <p>Prefix: <code>update</code></p> <p>Value: Vector of update operators</p> <p>Can start the pipeline: No</p> <p>Steps before: find, get, sort, limit, offset</p> <p>Steps after: -</p>"},{"location":"documentation/update/#operators","title":"Operators:","text":"<ul> <li>Inc - <code>inc{...}</code></li> <li>Set - <code>set{...}</code></li> </ul>"},{"location":"documentation/update/#example","title":"Example","text":"<p>Input:</p> <pre><code>collection|test|:q[\n    find[\n        gt{\n            value|num|:n|5|,\n        },\n    ],\n    update[\n        set{\n            value|num|:n|1000|,\n        },\n    ],\n];\n</code></pre> <p>Output:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            test|48b7ab32-0c02-418f-9db9-ea753bc7959e|,\n            test|4d67078d-c320-432b-bce9-56319498963b|,\n            test|7b96eff7-19b1-44c9-905d-7467caf05393|,\n            test|9285e8be-1d1f-4e7e-80cf-95686272e773|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|4|,\n        },\n    },\n];\n</code></pre>"},{"location":"release_notes/0.2.0/","title":"0.2","text":""},{"location":"release_notes/0.2.0/#new-features","title":"New Features","text":"<ul> <li><code>project{...}</code> step to modify the output data</li> </ul>"},{"location":"release_notes/0.2.0/#improvements","title":"Improvements","text":"<ul> <li>Overall speed improvements</li> </ul>"},{"location":"release_notes/0.2.0/#new-features-input-output-examples","title":"New features input output examples","text":"<p>Original data:</p> <pre><code>collection|users|:insert[\n    m{\n        s|name|:s|John|,\n        s|age|:n|30|,\n        s|address|:m{\n            s|street|:s|Park Avenue|,\n            s|city|:s|New York|,\n        },\n        s|emails|:v[\n            s|john@gmail.com|,\n            s|john_ny@outlook.com|,\n        ],\n    },\n    m{\n        s|name|:s|Mary|,\n        s|age|:n|25|,\n        s|address|:m{\n            s|street|:s|Rodeo Drive|,\n            s|city|:s|Los Angeles|,\n        },\n        s|emails|:v[\n            s|mary@gmail.com|,\n            s|mary_la@outlook.com|,\n        ],\n    },\n];\n</code></pre>"},{"location":"release_notes/0.2.0/#keep-the-value-of-the-field","title":"Keep the value of the field","text":"<p>The <code>project{...}</code> step allows you to modify the output data. For example, you can keep only the fields you need.</p> <p>Input</p> <pre><code>collection|users|:q[\n    find[\n    ],\n    sort[\n        asc(value|name|),\n    ],\n    project{\n        s|name|:keep,\n        s|age|:keep,\n    },\n];\n</code></pre> <p>Output</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            users|a8e74a57-8300-426f-b1eb-c174ff75bdac|:m{\n                s|name|:s|John|,\n                s|age|:n|30|,\n            },\n            users|ee7b70e8-4f76-4e45-9c3b-4c04ba315a75|:m{\n                s|age|:n|25|,\n                s|name|:s|Mary|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre>"},{"location":"release_notes/0.2.0/#using-existing-fields","title":"Using existing fields","text":"<p>Or you can set a new field using values from other:</p> <p>Input</p> <pre><code>collection|users|:q[\n    find[\n    ],\n    sort[\n        asc(value|name|),\n    ],\n    project{\n        s|username|:value|name|,\n    },\n];\n</code></pre> <p>Output</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            users|a8e74a57-8300-426f-b1eb-c174ff75bdac|:m{\n                s|username|:s|John|,\n            },\n            users|ee7b70e8-4f76-4e45-9c3b-4c04ba315a75|:m{\n                s|username|:s|Mary|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre>"},{"location":"release_notes/0.2.0/#set-a-new-value","title":"Set a new value","text":"<p>Or you can set a primitive value for the field:</p> <p>Input</p> <pre><code>collection|users|:q[\n    find[\n    ],\n    sort[\n        asc(value|name|),\n    ],\n    project{\n        s|title|:s|Dr. |,\n    },\n];\n</code></pre> <p>Output</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            users|a8e74a57-8300-426f-b1eb-c174ff75bdac|:m{\n                s|title|:s|Dr. |,\n            },\n            users|ee7b70e8-4f76-4e45-9c3b-4c04ba315a75|:m{\n                s|title|:s|Dr. |,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre> <p>Or you can set a map or vector as a field value using previously mentioned tools like <code>keep</code> or <code>value|...|</code>:</p> <p>Input for map</p> <pre><code>collection|users|:q[\n    find[\n    ],\n    sort[\n        asc(value|name|),\n    ],\n    project{\n        s|passport|:m{\n            s|name|:value|name|,\n        },\n        s|address|:m{\n            s|street|:keep,\n        },\n    },\n];\n</code></pre> <p>Output</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            users|a8e74a57-8300-426f-b1eb-c174ff75bdac|:m{\n                s|address|:m{\n                    s|street|:s|Park Avenue|,\n                },\n                s|passport|:m{\n                    s|name|:s|John|,\n                },\n            },\n            users|ee7b70e8-4f76-4e45-9c3b-4c04ba315a75|:m{\n                s|address|:m{\n                    s|street|:s|Rodeo Drive|,\n                },\n                s|passport|:m{\n                    s|name|:s|Mary|,\n                },\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre> <p>Input for vector</p> <pre><code>collection|users|:q[\n    find[\n    ],\n    sort[\n        asc(value|name|),\n    ],\n    project{\n        s|name|:v[\n            value|name|,\n        ],\n        s|emails|:v[\n            s|TEST|,\n            keep,\n        ],\n    },\n];\n</code></pre> <p>Output</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            users|a8e74a57-8300-426f-b1eb-c174ff75bdac|:m{\n                s|name|:v[\n                    s|John|,\n                ],\n                s|emails|:v[\n                    s|TEST|,\n                    s|john_ny@outlook.com|,\n                ],\n            },\n            users|ee7b70e8-4f76-4e45-9c3b-4c04ba315a75|:m{\n                s|emails|:v[\n                    s|TEST|,\n                    s|mary_la@outlook.com|,\n                ],\n                s|name|:v[\n                    s|Mary|,\n                ],\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre>"},{"location":"tutorial/native/","title":"Native","text":"<p>In this tutorial I'll create a database for the candy store to show the basic AnnaDB features.</p>"},{"location":"tutorial/native/#insert-primitive","title":"Insert primitive","text":"<p>let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the <code>categories</code> collection.</p> <p>Request:</p> <pre><code>collection|categories|:insert[\n    s|sweets|,\n];\n</code></pre> <p><code>collection|categories|</code> shows on which collection the query will be applied. In our case - <code>categories</code></p> <p><code>insert[...]</code> - is a query step. You can insert one or many objects using the <code>insert</code> operation.</p> <p><code>s|sweets|</code> - is the object to insert. In this case, it is a string primitive. Prefix <code>s</code> means that it is a string, <code>|</code> wrap the value of the primitive. Other primitive types could be found in the Data Types section.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            categories|b74c8f36-698d-41d5-b0cf-8fcbf92c9e3c|,\n        ],\n        s|meta|:insert_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>If everything is ok, in result will be returned <code>ok[...]</code> vector with responses for all the transaction pipelines. Each response contains <code>data</code> and <code>meta</code> information. In our case there is only one response with a vector of <code>ids</code> in <code>data</code> and a number of inserted objects in <code>meta</code></p>"},{"location":"tutorial/native/#insert-container","title":"Insert container","text":"<p>Let's insert a more complicated object now - a chocolate bar. It will have fields:</p> <ul> <li>name</li> <li>price</li> <li>category</li> </ul> <p>For the category, I'll use the already created one.</p> <p>Request:</p> <pre><code>collection|products|:insert[\n    m{\n        s|name|:s|Tony's|,\n        s|price|:n|5.95|,\n        s|category|:categories|b74c8f36-698d-41d5-b0cf-8fcbf92c9e3c|,\n    },\n];\n</code></pre> <p>The query is similar to the previous one, but the object is not a primitive, but a map. The value of the <code>category</code> field is a link, that was received after the previous insert.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|,\n        ],\n        s|meta|:insert_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response is nearly the same as before - link in data and number of inserted objects in meta.</p>"},{"location":"tutorial/native/#get-object","title":"Get object","text":"<p>Let's retrieve the information about this chocolate bar now. I'll use the <code>get</code> operation for this, to the object by id</p> <p>Request:</p> <pre><code>collection|products|:get[\n    products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|,\n];\n</code></pre> <p>This time I use the <code>get[...]</code> query step. Using this step you can retrieve one or many objects using object links.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|:m{\n                s|name|:s|Tony's|,\n                s|category|:s|sweets|,\n                s|price|:n|5.95|,\n            },\n        },\n        s|meta|:get_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>In the response here you can see the <code>objects{...}</code> map, where keys are links to objects and values are objects. <code>objects{}</code> map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step.</p> <p>The category was fetched automatically and the value was returned.</p> <p>Let's insert another chocolate bar there to have more objects in the collection:</p> <pre><code>collection|products|:insert[\n    m{\n        s|name|:s|Mars|,\n        s|price|:n|2|,\n        s|category|:categories|b74c8f36-698d-41d5-b0cf-8fcbf92c9e3c|,\n    },\n];\n</code></pre> <p>I use the same category id for this bar.</p>"},{"location":"tutorial/native/#modify-primitive","title":"Modify primitive","text":"<p>Let's modify the category to make it more accurate.</p> <p>Request:</p> <pre><code>collection|categories|:q[\n    get[\n        categories|b74c8f36-698d-41d5-b0cf-8fcbf92c9e3c|,\n    ],\n    update[\n        set{\n            root:s|chocolate|,\n        },\n    ],\n];\n</code></pre> <p>The query here consists of 2 steps. <code>Get the object by link</code> step and <code>modify this object</code> step. The <code>update[...]</code> operation is a vector of update operators. Read more about the update.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            categories|b74c8f36-698d-41d5-b0cf-8fcbf92c9e3c|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta.</p> <p>Let's take a look, at how this affected the chocolate objects.</p> <p>Request:</p> <pre><code>collection|products|:find[\n];\n</code></pre> <p>To find objects I use the <code>find[...]</code> operation. It is a vector of find operators. If it is empty, all the collection objects will be returned.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|:m{\n                s|category|:s|chocolate|,\n                s|price|:n|5.95|,\n                s|name|:s|Tony's|,\n            },\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|:m{\n                s|name|:s|Mars|,\n                s|price|:n|2|,\n                s|category|:s|chocolate|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre> <p>The category was changed for both products, as the category object was linked with these objects.</p>"},{"location":"tutorial/native/#modify-container","title":"Modify container","text":"<p>Now I'll increase the price of the bars, where it is less than 2</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n        lt{\n            value|price|:n|3|,\n        },\n    ],\n    update[\n        inc{\n            value|price|:n|2|,\n        },\n    ],\n];\n</code></pre> <p>The <code>find</code> step can stay before the <code>update</code> step as well. All the found objects will be updated. Read more about <code>find</code> operation and operators here.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response is similar to the previous one.</p> <p>Here is how all the products look like after update:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|:m{\n                s|name|:s|Tony's|,\n                s|category|:s|chocolate|,\n                s|price|:n|5.95|,\n            },\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|:m{\n                s|category|:s|chocolate|,\n                s|name|:s|Mars|,\n                s|price|:n|4|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre>"},{"location":"tutorial/native/#sort-objects","title":"Sort objects","text":"<p>To sort objects I'll use the <code>sort</code> operation against the price field</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n    ],\n    sort[\n        asc(value|price|),\n    ],\n];\n</code></pre> <p>The <code>sort[...]</code> operation is a vector of sort operators - <code>asc</code> and <code>desc</code>. Sort operators are modifiers, that contain paths to the sorting value. The <code>sort</code> operation is not an independent step, it can stay only after find-like operations, that return objects. You can read more about sort here</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|:m{\n                s|price|:n|4|,\n                s|name|:s|Mars|,\n                s|category|:s|chocolate|,\n            },\n            products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|:m{\n                s|name|:s|Tony's|,\n                s|category|:s|chocolate|,\n                s|price|:n|5.95|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|2|,\n        },\n    },\n];\n</code></pre> <p>Objects in the response are sorted by price now.</p> <p>It is useful to use <code>limit</code> and <code>offset</code> operations together with sort. You can read about them in the documentation</p>"},{"location":"tutorial/native/#make-projections","title":"Make projections","text":"<p>To get only the name and price fields I'll use the <code>project</code> operation</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n    ],\n    project{\n        s|name|:keep,\n        s|price|:keep,\n    },\n];\n</code></pre> <p>The <code>keep</code> operator is used to keep the value of the field or subfield in the output.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|:m{\n                s|price|:n|4|,\n                s|name|:s|Mars|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>To set a new field with already existing value I use <code>root</code> operator</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n    ],\n    project{\n        s|new_field|:value|category|,\n    },\n];\n</code></pre> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|:m{\n                s|new_field|:s|chocolate|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>It is possible to set any value to the field as well</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n    ],\n    project{\n        s|new_field|:s|new_value|,\n    },\n];\n</code></pre> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:objects{\n            products|160cdd92-703d-4e51-b31d-bfc9e190c1ba|:m{\n                s|new_field|:s|new_value|,\n            },\n        },\n        s|meta|:find_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre>"},{"location":"tutorial/native/#delete-objects","title":"Delete objects","text":"<p>You can use <code>delete</code> operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection.</p> <p>Request:</p> <pre><code>collection|products|:q[\n    find[\n        gt{\n            value|price|:n|5|,\n        },\n    ],\n    delete,\n];\n</code></pre> <p>The <code>delete</code> operation is a primitive without value.</p> <p>Response:</p> <pre><code>result:ok[\n    response{\n        s|data|:ids[\n            products|4a9e0f43-92f1-4d42-969b-6a148ac5c6ad|,\n        ],\n        s|meta|:update_meta{\n            s|count|:n|1|,\n        },\n    },\n];\n</code></pre> <p>The response contains affected ids in <code>data</code> and the number of deleted objects in <code>meta</code></p>"},{"location":"tutorial/python/","title":"Python","text":"<p>In this tutorial, I'll create a database for the candy store to show the basic AnnaDB features.</p>"},{"location":"tutorial/python/#connect","title":"Connect","text":"<p>The <code>Connection</code> class is used to connect to the AnnaDB</p> <pre><code>from annadb import Connection\nconn = Connection.from_connection_string(\"annadb://localhost:10001\")\n</code></pre>"},{"location":"tutorial/python/#insert-primitive","title":"Insert primitive","text":"<p>let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the <code>categories</code> collection.</p> <p>Request:</p> <pre><code>...\ncategories = conn[\"categories\"]\nresponse = categories.insert_one(\"sweets\").run()\n</code></pre> <p>There are two insert operators - <code>insert</code> and <code>insert_one</code>.</p> <ul> <li><code>insert</code> - operator to insert one or many objects. Response data is a list of   links (ids). Meta - number of inserted items.</li> <li><code>insert_one</code> - operator to insert a single object. Response data is a link.</li> </ul> <p>Let's get the inserted id</p> <pre><code>...\nsweets_id = response.data\n</code></pre>"},{"location":"tutorial/python/#insert-container","title":"Insert container","text":"<p>Let's insert a more complicated object now - a chocolate bar. It will have fields:</p> <ul> <li>name</li> <li>price</li> <li>category</li> </ul> <p>For the category, I'll use the already created one.</p> <p>Request:</p> <pre><code>products = conn[\"products\"]\nresponse = products.insert_one(\n{\n\"name\": \"Tony's\",\n\"price\": 5.95,\n\"category\": sweets_id\n}\n)\ntony_id = response.data\n</code></pre> <p>The query is similar to the previous one, but the object is not a str, but a dict. The value of the <code>category</code> field is a link, that was received after the previous insert.</p>"},{"location":"tutorial/python/#get-object","title":"Get object","text":"<p>Let's retrieve the information about this chocolate bar now.</p> <p>There are two ways to get objects by link: <code>get</code> and <code>get_one</code>. You can pass any number of links to the <code>get</code> operator. It will return an ordered dict of the link-object pars. <code>get_one</code> operator is used to get a single object.</p> <p>Request:</p> <pre><code>...\nresponse = products.get_one(tony_id).run()\nprint(response.data[\"category\"])\n&gt;&gt; &gt; sweets\n</code></pre> <p>The category was fetched automatically and the value was returned.</p> <p>Let's insert another chocolate bar there to have more objects in the collection:</p> <pre><code>...\nresponse = products.insert_one(\n{\n\"name\": \"Mars\",\n\"price\": 2,\n\"category\": sweets_id\n}\n).run()\nmars_id = response.data\n</code></pre> <p>I use the same category id for this bar.</p>"},{"location":"tutorial/python/#modify-primitive","title":"Modify primitive","text":"<p>Let's modify the category to make it more accurate.</p> <p>Request:</p> <pre><code>from annadb import Set, root\ncategories.get(sweets_id).update(Set({root: \"chocolate\"})).run()\n</code></pre> <p>The query here consists of 2 steps. <code>Get the object by link</code> step and <code>modify this object</code> step.</p> <p>The <code>root</code> object is a pointer to the value to update. For Vector and Map object it works a starting point in the path like <code>root.path.to.value</code></p> <p>Let's take a look, at how this affected the chocolate objects.</p> <p>Request:</p> <pre><code>response = products.all().run()\nfor k, v in response.data.items():\nprint(v[\"category\"])\n&gt;&gt;&gt; chocolate\n&gt;&gt;&gt; chocolate\n</code></pre> <p>The category was changed for both products, as the category object was linked with these objects.</p>"},{"location":"tutorial/python/#modify-container","title":"Modify container","text":"<p>Now I'll increase the price of the bars, where it is less than 2</p> <pre><code>from annadb import Inc\nproducts.find(root.price &lt; 3).update(Inc({root.price: 2})).run()\n</code></pre> <p>The <code>find</code> step can stay before the <code>update</code> step as well. All the found objects will be updated.</p> <p>Let's check the prices now:</p> <pre><code>...\nresponse = products.all().run()\nfor k, v in response.data.items():\nprint(v[\"name\"], v[\"price\"])\n&gt;&gt;&gt; Tony's 5.95\n&gt;&gt;&gt; Mars 4.0\n</code></pre>"},{"location":"tutorial/python/#sort-objects","title":"Sort objects","text":"<p>To sort objects I'll use the <code>sort</code> operation against the price field</p> <p>Request:</p> <pre><code>response = products.all().sort(+root.price).run()\nfor k, v in response.data.items():\nprint(v[\"name\"], v[\"price\"])\n&gt;&gt;&gt; Mars 4.0\n&gt;&gt;&gt; Tony's 5.95\n</code></pre> <p>Objects in the response are sorted by price now.</p> <p>It is useful to use <code>limit</code> and <code>offset</code> operations together with sort. You can read about them in the documentation</p>"},{"location":"tutorial/python/#make-projections","title":"Make projections","text":"<p>To get only the name and price fields I'll use the <code>project</code> operation</p> <p>Request:</p> <pre><code>from annadb import keep\nresponse = products.all().project({\n\"name\": keep,\n\"price\": keep\n}).run()\n</code></pre> <p>The <code>keep</code> operator is used to keep the value of the field or subfield in the output.</p> <p>To set a new field with already existing value I use <code>root</code> operator</p> <p>Request:</p> <pre><code>from annadb import root\nresponse = products.all().project({\n\"new_field\": root.category\n}).run()\n</code></pre> <p>It is possible to set any value to the field as well</p> <p>Request:</p> <pre><code>response = products.all().project({\n\"new_field\": \"some value\"\n}).run()\n</code></pre>"},{"location":"tutorial/python/#delete-objects","title":"Delete objects","text":"<p>You can use the <code>delete</code> operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection.</p> <p>Request:</p> <pre><code>products.find(root.price &lt; 5).delete().run()\n</code></pre>"}]}